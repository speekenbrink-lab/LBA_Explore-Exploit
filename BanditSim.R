#Simulate Restless Four armed Bandit task
  
  #Clean previous variables and set starting variables
  rm(list = ls())
  #The Lower DELTA is, the more exploration
  #The Lower GAMMA is, the more exploration
  #The Lower OMEGA is, the more exploration
  #For type 1, PHI of 0, DELTA of .2, GAMMA of 1, and OMEGA of 10 give similar Exploit rates (with A of .01, B of 1)
  params <- c(.5, 1, .2, .2, .5, 25, 0, .5, 1, 2, 20, 1, 1, 300)
  trialNum = 200
  simNum = 500
  
  #Required packages and files----
  require('tidyverse')
  source('RW.R', TRUE)
  source('KalmanFilter.R', TRUE)
  source('LBASim.R', TRUE)
  source('runBanditSimple.R', TRUE)
  source('runBandit_TwoLBA.R', TRUE)
  source('runBandit_SDunc.R', TRUE)
  source('runBandit_SPunc.R', TRUE)
  
  #Determine which models to run----
  #Run the simple simulator? 
  simpleSim <- 0

  #Run the dual accumulator?
  dualSim <- 0
  
  #Run the uncertainty SD accumulator
  sdSim <- 1
  
  #Run the uncertainty Start point accumulator 
  spSim <- 1
  
  #What style of uncertianty?
  #1 is simply how long since the option was last picked
  #2 is the observed standard deviation on each option across all scores
  #3 is the observed standard deviation across all rewards
  #4 is the prediction error from the last trial. 
  #5 is Kalman filter where K and S create the distribution for uncertainty (Width of SD of driftrate or bonus to A)
  uncStyle <- 5
  
  #Learnstyle:
  #1 is RW
  #2 is KF (If you're using Unc Style 5, then it's Kalman Filter by Default)
  learnStyle = 2
  
  #Set parameters (all in caps)----
  #Start-point bound for simple model or exploit
  A <- params[1]
  #Threshold
  B <- params[2]
  #Decision Delay
  T0 <- params[3]
  #Standard Deviation
  SD_V <- params[4]
  #Learning Rate
  ALPHA <- params[5]
  #Starting values
  QSTART <- params[6]
  #Scaling parameter for drift-rates
  PHI <- params[7]
  #Start point parameter for exploration (Dual Model)
  A_EXPLORE <- params[8]
  #Threshold parameter for exploration (Dual Model)
  B_EXPLORE <- params[9]
  #Standard deviation in drift rate for exploration (Dual Model)
  SD_V_EXPLORE <- params[10]
  #Starting values for uncertainty
  UNCSTART <- params[11]
  #Scaling parameter for Exploration Accumulators (Dual Model)
  DELTA <- params[12]
  #Scaling parameter for Uncertainty SDs
  GAMMA <- params[13]
  #Scaling parameter for Uncertainty SPs
  OMEGA <- params[14]
  
  
  #Choice and RT trackers ----
  simList <- matrix(ncol = simNum, nrow = trialNum)
  tradExploitList <- matrix(ncol = simNum, nrow = trialNum)
  RTList <- matrix(ncol = simNum, nrow = trialNum)
  
  
  #run one accumulator simple model ----
  if (simpleSim == 1) {
    for (p in 1:simNum) {
      sim <- runBanditSimple(A, B, T0, SD_V, ALPHA, QSTART, PHI, trialNum, uncStyle, learnStyle)
      simList[1:trialNum, p] <- sim$optimal
      tradExploitList[1:trialNum, p] <- sim$tradExploit
      RTList[1:trialNum, p] <- sim$rts
    }
    condensedHolder <- apply(simList, 1, mean)
    tradExploitHolder <- apply(tradExploitList, 1, mean)

    #Handle Reaction Times
    for (p in 1:simNum) {
      holder <- data.frame(trial = 1:trialNum, averageRT = RTList[1:trialNum, p], exploit = tradExploitList[1:trialNum, p])
      if (p == 1) {
        RTFinal <- holder
      } else {
        RTFinal <- merge(RTFinal, holder, all = TRUE)
      }
    }
    
    #Put them into One Holder tibble ----
    condensedHolder <- tibble(trial = 1:trialNum, Optimal = condensedHolder, Model = 'Simple', Style = uncStyle)
    tradExploitHolder <- tibble(trial = 1:trialNum, Exploit = tradExploitHolder, Model = 'Simple', Style = uncStyle)
    RTHolder <- tibble(trial = RTFinal$trial, RT = RTFinal$averageRT, Exploit = RTFinal$exploit, Model = 'Simple', Style = uncStyle)
    
    #Collect the tibbles!----
    if (!exists('condensedTib')) {
      condensedTib <-  condensedHolder
    } else {
      condensedTib <-  merge(condensedTib, condensedHolder, all = TRUE)
    }
    if (!exists('tradExploitTib')) {
      tradExploitTib <-  tradExploitHolder
    } else {
      tradExploitTib <-  merge(tradExploitTib, tradExploitHolder, all = TRUE)
    }
    if (!exists('RTTib')) {
      RTTib <-  RTHolder
    } else {
      RTTib <-  merge(RTTib, RTHolder, all = TRUE)
    }
    #----
  }
  
  #Run the two accumulator model ----
  if (dualSim == 1){
    for (p in 1:simNum) {
      sim <- runBandit_TwoLBA(A, B, T0, SD_V, ALPHA, QSTART, PHI,  
                              A_EXPLORE, B_EXPLORE, SD_V_EXPLORE, UNCSTART, DELTA, 
                              trialNum, uncStyle, learnStyle)
      simList[1:trialNum, p] <- sim$optimal
      tradExploitList[1:trialNum, p] <- sim$traditionalExploit
      RTList[1:trialNum, p] <- sim$rts
    }
    condensedHolder <- apply(simList, 1, mean)
    tradExploitHolder <- apply(tradExploitList, 1, mean)
    
    #Handle Reaction Times
    for (p in 1:simNum) {
      holder <- data.frame(trial = 1:trialNum, averageRT = RTList[1:trialNum, p], exploit = tradExploitList[1:trialNum, p])
      if (p == 1) {
        RTFinal <- holder
      } else {
        RTFinal <- merge(RTFinal, holder, all = TRUE)
      }
    }
    
    #Put them into One Holder tibble ----
    condensedHolder <- tibble(trial = 1:trialNum, Optimal = condensedHolder, Model = 'Dual', Style = uncStyle)
    tradExploitHolder <- tibble(trial = 1:trialNum, Exploit = tradExploitHolder, Model = 'Dual', Style = uncStyle)
    RTHolder <- tibble(trial = RTFinal$trial, RT = RTFinal$averageRT, Exploit = RTFinal$exploit, Model = 'Dual', Style = uncStyle)
    
    #Collect the tibbles!----
    if (!exists('condensedTib')) {
      condensedTib <-  condensedHolder
    } else {
      condensedTib <-  merge(condensedTib, condensedHolder, all = TRUE)
    }
    if (!exists('tradExploitTib')) {
      tradExploitTib <-  tradExploitHolder
    } else {
      tradExploitTib <-  merge(tradExploitTib, tradExploitHolder, all = TRUE)
    }
    if (!exists('RTTib')) {
      RTTib <-  RTHolder
    } else {
      RTTib <-  merge(RTTib, RTHolder, all = TRUE)
    }
    #----
  }
  
  #Uncertainty influences Standard deviation of responses ----
  if (sdSim == 1) {
    for (p in 1:simNum) {
      sim <- runBandit_SDunc(A, B, T0, ALPHA, QSTART, PHI,
                             UNCSTART, GAMMA, trialNum, uncStyle, learnStyle)
      simList[1:trialNum, p] <- sim$optimal
      tradExploitList[1:trialNum, p] <- sim$traditionalExploit
      RTList[1:trialNum, p] <- sim$rts
    }
    condensedHolder <- apply(simList, 1, mean)
    tradExploitHolder <- apply(tradExploitList, 1, mean)
    
    #Handle Reaction Times
    for (p in 1:simNum) {
      holder <- data.frame(trial = 1:trialNum, averageRT = RTList[1:trialNum, p], exploit = tradExploitList[1:trialNum, p])
      if (p == 1) {
        RTFinal <- holder
      } else {
        RTFinal <- merge(RTFinal, holder, all = TRUE)
      }
    }
    
    #Put them into One Holder tibble ----
    condensedHolder <- tibble(trial = 1:trialNum, Optimal = condensedHolder, Model = 'SDunc', Style = uncStyle)
    tradExploitHolder <- tibble(trial = 1:trialNum, Exploit = tradExploitHolder, Model = 'SDunc', Style = uncStyle)
    RTHolder <- tibble(trial = RTFinal$trial, RT = RTFinal$averageRT, Exploit = RTFinal$exploit, Model = 'SDunc', Style = uncStyle)
    
    #Collect the tibbles!----
    if (!exists('condensedTib')) {
      condensedTib <-  condensedHolder
    } else {
      condensedTib <-  merge(condensedTib, condensedHolder, all = TRUE)
    }
    if (!exists('tradExploitTib')) {
      tradExploitTib <-  tradExploitHolder
    } else {
      tradExploitTib <-  merge(tradExploitTib, tradExploitHolder, all = TRUE)
    }
    if (!exists('RTTib')) {
      RTTib <-  RTHolder
    } else {
      RTTib <-  merge(RTTib, RTHolder, all = TRUE)
    }
    #----
  }
  
  #Uncertainty influences the Start point of response ----
  if (spSim == 1) {
    for (p in 1:simNum) {
      sim <- runBandit_SPunc(A, B, T0, SD_V, ALPHA, QSTART, PHI,
                             UNCSTART, OMEGA, trialNum, uncStyle, learnStyle)
      simList[1:trialNum, p] <- sim$optimal
      tradExploitList[1:trialNum, p] <- sim$traditionalExploit
      RTList[1:trialNum, p] <- sim$rts
    }
    condensedHolder <- apply(simList, 1, mean)
    tradExploitHolder <- apply(tradExploitList, 1, mean)
    
    #Handle Reaction Times
    for (p in 1:simNum) {
      holder <- data.frame(trial = 1:trialNum, averageRT = RTList[1:trialNum, p], exploit = tradExploitList[1:trialNum, p])
      if (p == 1) {
        RTFinal <- holder
      } else {
        RTFinal <- merge(RTFinal, holder, all = TRUE)
      }
    }
    
    #Put them into One Holder tibble ----
    condensedHolder <- tibble(trial = 1:trialNum, Optimal = condensedHolder, Model = 'SPunc', Style = uncStyle)
    tradExploitHolder <- tibble(trial = 1:trialNum, Exploit = tradExploitHolder, Model = 'SPnc', Style = uncStyle)
    RTHolder <- tibble(trial = RTFinal$trial, RT = RTFinal$averageRT, Exploit = RTFinal$exploit, Model = 'SPunc', Style = uncStyle)
    
    #Collect the tibbles!----
    if (!exists('condensedTib')) {
      condensedTib <-  condensedHolder
    } else {
      condensedTib <-  merge(condensedTib, condensedHolder, all = TRUE)
    }
    if (!exists('tradExploitTib')) {
      tradExploitTib <-  tradExploitHolder
    } else {
      tradExploitTib <-  merge(tradExploitTib, tradExploitHolder, all = TRUE)
    }
    if (!exists('RTTib')) {
      RTTib <-  RTHolder
    } else {
      RTTib <-  merge(RTTib, RTHolder, all = TRUE)
    }
    #----
  }
  
  
  #Make Graphs----
  
  ggplot(data = condensedTib, mapping = aes(x = trial, y = Optimal, group = 1)) +
    geom_line() +
    coord_cartesian(ylim = c(0, 1)) +
    facet_wrap(~ Model)
  
  ggplot(data = tradExploitTib, mapping = aes(x = trial, y = Exploit, group = 1)) +
    geom_line() +
    coord_cartesian(ylim = c(0, 1)) +
    facet_wrap(~ Model)
  
  RTTib$Exploit <- factor(RTTib$Exploit, levels = c(0, 1), labels = c('explore', 'exploit'))
  
  ggplot(data = RTTib, mapping = aes(x = RT, fill = Exploit)) +
    geom_histogram(binwidth = .2, position = 'dodge') +
    coord_cartesian(xlim = c(0, 4)) +
    facet_wrap(~ Model)
  
  #Notes:
  #All driftrates normalised to one, but modified by the scaling parameter PHI (or DELTA for exploration in Dual model)
  #Different types of uncertainty easily addable, but need to be added in all editions of the code (perhaps this needs a function?)