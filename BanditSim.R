  #Simulate Restless Four armed Bandit task
    
    #Clean previous variables and set starting variables
    rm(list = ls())
    #The Lower DELTA is, the more exploration
    #The Lower GAMMA is, the more exploration
    #The Lower OMEGA is, the more exploration
    #For type 1, DELTA of .2, GAMMA of 1, and OMEGA of 10 give similar Exploit rates (with A of .01, B of 1)
    params <- c(.5, 1, .2, .2, .5, 25, 5, .5, 1, 2, 20, 1, 25, 50)
    trialNum = 200
    simNum = 100
    
    #Required packages and files----
    require('tidyverse')
    source('RW.R', TRUE)
    source('KalmanFilter.R', TRUE)
    source('LBASim.R', TRUE)
    source('runBanditSimple.R', TRUE)
    source('runBandit_TwoLBA.R', TRUE)
    source('runBandit_SDunc.R', TRUE)
    source('runBandit_SPunc.R', TRUE)
    source('addUnc.R', TRUE)
    source('runBandit_All.R', TRUE)
    
    #What style of uncertianty? ----
    #1 is simply how long since the option was last picked
    #2 is the observed standard deviation on each option across all scores
    #3 is the observed standard deviation across all rewards
    #4 is the prediction error from the last trial. 
    #5 is Kalman filter where K and S create the distribution for uncertainty (Width of SD of driftrate or bonus to A)
    #6 is the observed SD for all rewards on the last 10 trials (Perhaps make this a parameter later) (Temperature set high before)
    uncStyle <- 6
    
    #Learnstyle:
    #1 is RW
    #2 is KF (If you're using Unc Style 5, then it's Kalman Filter by Default)
    learnStyle = 2
    
    #Set parameters (all in caps)----
    #Start-point bound for simple model or exploit
    A <- params[1]
    #Threshold
    B <- params[2]
    #Decision Delay
    T0 <- params[3]
    #Standard Deviation
    SD_V <- params[4]
    #Learning Rate
    ALPHA <- params[5]
    #Starting values
    QSTART <- params[6]
    #Scaling parameter for drift-rates
    THETA <- params[7]
    #Start point parameter for exploration (Dual Model)
    A_EXPLORE <- params[8]
    #Threshold parameter for exploration (Dual Model)
    B_EXPLORE <- params[9]
    #Standard deviation in drift rate for exploration (Dual Model)
    SD_V_EXPLORE <- params[10]
    #Starting values for uncertainty
    UNCSTART <- params[11]
    #Scaling parameter for Exploration Accumulators (Dual Model)
    DELTA <- params[12]
    #Scaling parameter for Uncertainty SDs
    GAMMA <- params[13]
    #Scaling parameter for Uncertainty SPs
    OMEGA <- params[14]
    
    
    #Choice and RT trackers ----
    simList <- matrix(ncol = simNum, nrow = trialNum)
    tradExploitList <- matrix(ncol = simNum, nrow = trialNum)
    RTList <- matrix(ncol = simNum, nrow = trialNum)
    EV_DiffList <- matrix(ncol = simNum, nrow = trialNum)
    Unc_MaxList <- matrix(ncol = simNum, nrow = trialNum)
    
    #Run the LBAs
    #1 is Simple LBA
    #2 is the dual LBA
    #3 is the SD uncertainty LBA
    #4 is the SP uncertainty LBA
    #5 is combination of SD and SP LBA, SD on standard dev, SP on Kalman S/Time since last picked in RW
    for (k in 1:4) {
      if (k == 2) {
        next()
      }
      for (p in 1:simNum) {
        sim <- runBandit_All(A, B, T0, SD_V, ALPHA, QSTART, THETA,
                      trialNum, uncStyle, learnStyle, k,
                      A_EXPLORE, B_EXPLORE, SD_V_EXPLORE, UNCSTART,
                      OMEGA,
                      GAMMA,
                      DELTA)
        simList[1:trialNum, p] <- sim$optimal
        tradExploitList[1:trialNum, p] <- sim$tradExploit
        RTList[1:trialNum, p] <- sim$rts
        EV_DiffList[1:trialNum, p] <- sim$EV_Diff
        Unc_MaxList[1:trialNum, p] <- sim$Unc_Max
      }
      condensedHolder <- apply(simList, 1, mean)
      tradExploitHolder <- apply(tradExploitList, 1, mean)
  
      #Handle Reaction Times
      for (p in 1:simNum) {
        holder <- data.frame(trial = 1:trialNum, averageRT = RTList[1:trialNum, p], exploit = tradExploitList[1:trialNum, p],
                             EV_Diff = EV_DiffList[1:trialNum, p], Unc_Max = Unc_MaxList[1:trialNum, p])
        if (p == 1) {
          RTFinal <- holder
        } else {
          RTFinal <- merge(RTFinal, holder, all = TRUE)
        }
      }
  
      #Put them into One Holder tibble ----
      condensedHolder <- tibble(trial = 1:trialNum, Optimal = condensedHolder, Model = k, Style = uncStyle)
      tradExploitHolder <- tibble(trial = 1:trialNum, Exploit = tradExploitHolder, Model = k, Style = uncStyle)
      RTHolder <- tibble(trial = RTFinal$trial, RT = RTFinal$averageRT, Exploit = RTFinal$exploit,
                         EV_Diff = RTFinal$EV_Diff, Unc_Max = RTFinal$Unc_Max, 
                         Model = k, Style = uncStyle)
  
      #Collect the tibbles!----
      if (!exists('condensedTib')) {
        condensedTib <-  condensedHolder
      } else {
        condensedTib <-  merge(condensedTib, condensedHolder, all = TRUE)
      }
      if (!exists('tradExploitTib')) {
        tradExploitTib <-  tradExploitHolder
      } else {
        tradExploitTib <-  merge(tradExploitTib, tradExploitHolder, all = TRUE)
      }
      if (!exists('RTTib')) {
        RTTib <-  RTHolder
      } else {
        RTTib <-  merge(RTTib, RTHolder, all = TRUE)
      }
    }
    
    RTTib$Model <- factor(RTTib$Model, levels = c(1, 2, 3, 4), labels = c('Simple', 'Dual', 'SDUnc', 'SPUnc'))
    tradExploitTib$Model <- factor(tradExploitTib$Model, levels = c(1, 2, 3, 4), labels = c('Simple', 'Dual', 'SDUnc', 'SPUnc'))
    condensedTib$Model <- factor(condensedTib$Model, levels = c(1, 2, 3, 4), labels = c('Simple', 'Dual', 'SDUnc', 'SPUnc'))
  
    #Make Graphs----
    ggplot(data = condensedTib, mapping = aes(x = trial, y = Optimal, group = 1)) +
      geom_line() +
      coord_cartesian(ylim = c(0, 1)) +
      facet_wrap(~ Model) +
      ggtitle('Optimal responding')
    
    if (simNum >= 100) {
      graphName <- paste(c("Graphs/OptResp_Unc",uncStyle,'_learn',learnStyle,'.png'), collapse = '')
      ggsave(filename = graphName, width = 10, height = 8)
    }
    
    ggplot(data = tradExploitTib, mapping = aes(x = trial, y = Exploit, group = 1)) +
      geom_line() +
      coord_cartesian(ylim = c(0, 1)) +
      facet_wrap(~ Model) +
      ggtitle('Exploitation (Best known response)')
    
    if (simNum >= 100) {
      graphName <- paste(c("Graphs/Exploit_Unc",uncStyle,'_learn',learnStyle,'.png'), collapse = '')
      ggsave(filename = graphName, width = 8, height = 8)
    }
    
    RTTib$Exploit <- factor(RTTib$Exploit, levels = c(0, 1), labels = c('explore', 'exploit'))
  
    ggplot(data = RTTib, mapping = aes(x = RT, fill = Exploit)) +
      geom_histogram(binwidth = .2, position = 'dodge') +
      coord_cartesian(xlim = c(0, 4)) +
      facet_wrap(~ Model) +
      ggtitle('Count of response times')
    
    if (simNum >= 100) {
      graphName <- paste(c("Graphs/CountRT_Unc",uncStyle,'_learn',learnStyle,'.png'), collapse = '')
      ggsave(filename = graphName, width = 8, height = 8)
    }
    
    RTTib %>% 
      count(EV_Diff = cut_width(EV_Diff, 10), Unc_Max = cut_width(Unc_Max, 10), Model, Exploit) %>% 
      filter(n > trialNum * simNum / 100) %>%
    ggplot(aes(x = EV_Diff, y = Unc_Max)) +
      geom_tile(aes(fill = n)) +
      facet_grid(Exploit ~ Model) +
      ggtitle('Count of most common trials')
    
    if (simNum >= 100) {
      graphName <- paste(c("Graphs/CountTrialType_Unc",uncStyle,'_learn',learnStyle,'.png'), collapse = '')
      ggsave(filename = graphName, width = 8, height = 8)
    }
    
    
    RTTib %>% 
      group_by(EV_Diff = cut_width(EV_Diff, 10), Unc_Max = cut_width(Unc_Max, 10), Model, Exploit) %>% 
      summarise(count = sum(RT > 0), RT = mean(RT)) %>% 
      filter(count > trialNum * simNum / 100) %>% 
      ggplot(aes(x = EV_Diff, y = Unc_Max)) +
      geom_tile(aes(fill = RT)) +
      facet_grid(Exploit ~ Model) +
      ggtitle('Mean RT given EV diff and Highest Unc (bottom 1% of trials excluded)')
    
    if (simNum >= 100) {
      graphName <- paste(c("Graphs/MeanRT_Unc",uncStyle,'_learn',learnStyle,'.png'), collapse = '')
      ggsave(filename = graphName, width = 8, height = 8)
    }
    
    
    #Notes:
    #All driftrates normalised to one, but modified by the scaling parameter THETA (or DELTA for exploration in Dual model)
    #Different types of uncertainty easily addable, but need to be added in all editions of the code (perhaps this needs a function?)