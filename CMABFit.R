# CMABFit <- function(A = .5, B = 3, T0 = .3, MEAN_V = 2, SD_V = 1, ALPHA = .4, QSTART = .1, rawData) {
CMABFit2 <- function(params, rawData) {
  
  # #Temp variables
  # #Start point variability
  A <- params[1]
  # #Threshold
  B <- params[2]
  # #Time to start accumulation
  T0 <- params[3]
  # #Drift Rates (decided in the code)
  # MEAN_V <- rep(params[4], times = 2)
  # #Standard deviation of drift rates
  SD_V <- rep(params[4], times = 2)
  # #Learning rate
  ALPHA <- params[5]
  # #Start point for values
  QSTART <- params[6]
  # #
  PHI <- params[7]
  
  #Paramter Bounding ----
  if (A < 0 | A > 10){
    NLL <- 100000
    return(NLL)
  } else if (B < .5 | B > 10){
    NLL <- 100000  
    return(NLL)
  } else if (T0 < 0 | T0 > 10){
    NLL <- 100000  
    return(NLL)
  } else if (SD_V[1] <= 0 | SD_V[1] > 5){
    NLL <- 100000 
    return(NLL)
  } else if (ALPHA < .05 | ALPHA > 1){
    NLL <- 100000  
    return(NLL)
  } else if (QSTART < 0 | QSTART > 30){
    NLL <- 100000 
    return(NLL)
  } else if (PHI < 1 | PHI > 10){
    NLL <- 100000  
    return(NLL)
  }
  
  #Ensure A is less than B ----
  if (A > B) {
    NLL <- 1000001
    return(NLL)
  }
  cond <- 1
  participant <- 2
  
  #Set trial info
  trialNum = 448
  secOneTrialNum = 256
  secTwoTrialNum = 192
  choiceNum = 2
  
  #Read in raw Data
  # rawData <- readData(trialNum, secOneTrialNum, secTwoTrialNum, cond, participant)
  
  #Perform Learning in Trials
  
  #Q values for each action
  Qs <- rep(QSTART, times = 8)
  QTable <- matrix(ncol = 8, nrow = trialNum)
  #Mean values for each response given the cues
  trialVals <- rep(0, times = 2)
  #Likelihoods of the response
  likelihood <- rep(0, times = trialNum)
  tempLikelihoods <- rep(0, times = 2)
  
  #Including T0? Take it away from RTs before running the model?
  rawData <- mutate(rawData, fixedRT = RT - T0)
  
  for (t in 1:trialNum){
    #Which cues are on screen
    cuesPres <- rep(NA, times = 4)
    #Find cues in the trial
    cuesPres[rawData$cueOne[t]] <- 1
    cuesPres[rawData$cueTwo[t]] <- 1
    
    QTable[t, 1:8] <- Qs
    
    #Learn based on decision
    if (rawData$choice[t] == 1) {
      Qs[1:4] <- RW(ALPHA, Qs[1:4], rawData$reward[t], cuesPres)
    } else if (rawData$choice[t] == 2) {
      Qs[5:8] <- RW(ALPHA, Qs[5:8], rawData$reward[t], cuesPres)
    }
    
    #Work out likelihood of making that response
    #Transform presented cues for values for each choice
    trialVals[1] <- mean(cuesPres*QTable[t, 1:4], na.rm = TRUE)
    trialVals[2] <- mean(cuesPres*QTable[t, 5:8], na.rm = TRUE)
    
    #Transform expected value into mean-driftrate
    driftRates <- (trialVals)/PHI
    
    #Calculate the Defective CDF (the likelihood of making each response)
    for (k in 1:choiceNum) {
      holder <- integrate('LBAFit', lower = 0, upper = Inf, A = A, B = B, T0 = T0, 
                          MEAN_V = driftRates, SD_V = SD_V, choiceNum = choiceNum, evalNum = k)
      tempLikelihoods[k] <- holder[1]
    }
    
    tempLikelihoods <- array(as.numeric(unlist(tempLikelihoods)))
    
    likelihood[t] <- tempLikelihoods[rawData$choice[t]]
  }
  
  NLL = -sum(log(likelihood), na.rm = TRUE)
  
  if (A > B) {
    NLL <- 10000
  }
  
  print(NLL)
  return(NLL)
  
}