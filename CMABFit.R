# CMABFit <- function(A = .5, B = 3, T0 = .3, MEAN_V = 2, SD_V = 1, ALPHA = .4, QSTART = .1, rawData) {
CMABFit <- function(params, rawData) {

# #Temp variables
# #Start point variability
A <- params[1]
# #Threshold
B <- params[2]
# #Time to start accumulation
T0 <- params[3]
# #Drift Rates
 MEAN_V <- rep(params[4], times = 2)
# #Standard deviation of drift rates
 SD_V <- rep(params[5], times = 2)
# #Learning rate
ALPHA <- params[6]
# #Start point for values
QSTART <- params[7]
# #
PHI <- 2

cond <- 1
participant <- 2

#Set trial info
trialNum = 448
secOneTrialNum = 256
secTwoTrialNum = 192
choiceNum = 2

#Read in raw Data
# rawData <- readData(trialNum, secOneTrialNum, secTwoTrialNum, cond, participant)

#Perform Learning in Trials

#Q values for each action
Qs <- rep(QSTART, times = 8)
QTable <- matrix(ncol = 8, nrow = trialNum)
#Mean values for each response given the cues
trialVals <- rep(0, times = 2)
#Likelihoods of the response
likelihood <- 0
tempLikelihoods <- rep(0, times = 2)

for (t in 1:trialNum){
  #Which cues are on screen
  cuesPres <- rep(NA, times = 4)
  #Find cues in the trial
  cuesPres[rawData$cueOne[t]] <- 1
  cuesPres[rawData$cueTwo[t]] <- 1
  
  QTable[t, 1:8] <- Qs
  
  #Learn based on decision
  if (rawData$choice[t] == 1) {
    Qs[1:4] <- RW(ALPHA, Qs[1:4], rawData$reward[t], cuesPres)
  } else if (rawData$choice[t] == 2) {
    Qs[5:8] <- RW(ALPHA, Qs[5:8], rawData$reward[t], cuesPres)
  }
  
  #Work out likelihood of making that response
  #Transform presented cues for values for each choice
  trialVals[1] <- mean(cuesPres*QTable[t, 1:4], na.rm = TRUE)
  trialVals[2] <- mean(cuesPres*QTable[t, 5:8], na.rm = TRUE)
  
  #Transform expected value into mean-driftrate
  driftRates <- (trialVals)/PHI
  
  #Including T0? Take it away from RTs before running the model?
  rawData <- mutate(rawData, fixedRT = RT - T0)
  
  
  #Normalise Likelihoods
  # driftDist <- 0
  # for (i in 1:choiceNum) {
  #   holder <- integrate(dnorm, lower = 0, upper = Inf, mean = driftRates[i], sd = SD_V[i])
  #   driftDist[i] <- array(as.numeric(unlist(holder[1])))
  # }
  
  #Calculate the Defective CDF (the likelihood of making each response)
  for (k in 1:choiceNum) {
    holder <- integrate('LBAFit', lower = 0, upper = Inf, A = A, B = B, T0 = T0, 
                        MEAN_V = driftRates, SD_V = SD_V, choiceNum = choiceNum, evalNum = k, subdivisions = 200)
    tempLikelihoods[k] <- holder[1]
  }
  
  tempLikelihoods <- array(as.numeric(unlist(tempLikelihoods)))
  
  # lol <- tempLikelihoods/prod(driftDist)
  
  likelihood[t] <- tempLikelihoods[rawData$choice[t]]
  
  #Keep this in for now, but wait for Chris' response
  likelihood[t] <- likelihood[t] / sum(tempLikelihoods)
}

NLL = -sum(log(likelihood), na.rm = TRUE)

return(NLL)

}

