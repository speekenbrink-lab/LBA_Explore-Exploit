# CMABFit <- function(A = .5, B = 3, T0 = .3, MEAN_V = 2, SD_V = 1, ALPHA = .4, QSTART = .1, rawData) {
CMABFit <- function(params, rawData, trialNum, S2QStart, LBAType, uncType) {
  
  #Assign params to values ----
  #A is the start-point for each option, let all As be different initially to account for bias
  A = rep(0, 2)
  A[1] <- params[1]
  A[2] <- params[2]
  
  #B is the bound. To keep things identifiable, make the bound set across all arms
  B <- rep(params[3], 2)
  
  #If A's are greater than B return Null
  if ((A[1] > B[1]) | (A[2] > B[2])){
    NLL <-  100000
    # print('lol')
    return(NLL)
  }
  
  #T0 is the amount of Non-decision time
  T0 <- rep(params[4], 2)
  
  #THETA is the temperature parameter for all models
  THETA <- params[5]
  
  #QSTART is a free parameter and helps determine whether participants will be optimistic or not at the beginning by determining starting values
  if (any(is.nan(S2QStart))) {
    QSTART <- rep(params[6], 8)
  } else {
    QSTART <- S2QStart
  }
  
  #ZETA is the prospect theory power
  ZETA <- params[7]
  
  #DELTA is the loss-aversion parameter
  DELTA <- params[8]
  
  #ALPHA_POS is the learning rate parameter for RW in the positive direction (Pedersen et al., 2017)
  ALPHA_POS <- params[9]
  #ALPHA_NEG is the learning rate parameter for RW in the negative direction (Pedersen et al., 2017)
  ALPHA_NEG <- params[10]
  
  #SD_V is the drift-rate parameter, again we'll keep this constant (unless we're testing a model where we alter it)
  SD_V <- rep(params[11], 2)
  
  #UNCSTART is where uncertainty expectations start at 
  UNCSTART <- rep(params[12], 8)
  
  #GAMMA is a general parameter that transforms uncertainty (although it will act differently in different models)
  GAMMA <- params[13]
  
  #preallocate variables ----
  #Set trial info
  choiceNum = 2
  
  #Perform Learning in Trials
  
  #Q values for each action
  #Qs are for EVs
  Qs <- QSTART
  QTable <- matrix(ncol = 8, nrow = trialNum)
  driftRates <- rep(0, 2)
  #See what values have been observed on which options
  valuesObserved <- matrix(ncol = 4, nrow = trialNum)
  #Uncertainty tracker
  Uncs <- UNCSTART
  UncTable <- matrix(ncol = 8, nrow = trialNum)
  trialUncs <- rep(2, 0)
  #Mean values for each response given the cues
  trialVals <- rep(0, times = 2)
  #Likelihoods of the response
  likelihood <- rep(0, times = trialNum)
  # tempLikelihoods <- rep(0, times = 2)
  
  #Including T0? Take it away from RTs before running the model?
  rawData <- mutate(rawData, fixedRT = RT - T0)
  
  #Model ----
  for (t in 1:(trialNum)){
    #Which cues are on screen
    cuesPres <- rep(NA, times = 4)
    #Find cues in the trial
    cuesPres[rawData$cueOne[t]] <- 1
    cuesPres[rawData$cueTwo[t]] <- 1
    
    QTable[t, 1:8] <- Qs
    UncTable[t, 1:8] <- Uncs
    
    #Calculate utility
    if (rawData$reward[t] >= 0) {
      utility <- rawData$reward[t] ^ ZETA
    } else {
      utility <- -DELTA * ((abs(rawData$reward[t])) ^ ZETA)
    }
    
    PE = utility - sum(Qs * cuesPres, na.rm = TRUE)
    if (PE < 0) {
      ALPHA = ALPHA_NEG
    } else {
      ALPHA = ALPHA_POS
    }
    
    #Learn based on decision
    if (rawData$choice[t] == 1) {
      Qs[1:4] <- RW(ALPHA, Qs[1:4], utility, cuesPres)
    } else if (rawData$choice[t] == 2) {
      Qs[5:8] <- RW(ALPHA, Qs[5:8], utility, cuesPres)
    }
    
    valuesObserved[t, rawData$comb[t]] <- rawData$reward[t]
    
    #Work out likelihood of making that response
    #Transform presented cues for values for each choice
    trialVals[1] <- mean(cuesPres*QTable[t, 1:4], na.rm = TRUE)
    trialVals[2] <- mean(cuesPres*QTable[t, 5:8], na.rm = TRUE)
    
    #Transform expected value into mean-driftrate
    for (e in 1:2) {
      driftRates[e] <-  exp(trialVals[e]/THETA) / sum(exp(trialVals/THETA))
    }
    
    #Calculate the Defective CDF (the likelihood of making each response)
    # holder <- integrate('LBAFit', lower = 0, upper = rawData$fixedRT[t], A = A, B = B,
    #                       MEAN_V = driftRates, SD_V = SD_V, choiceNum = choiceNum)
    if (LBAType == 1) { #Simple LBA
      likelihood[t] <- n1CDF(rt = rawData$RT[t], A = A, b = B, t0 = T0, mean_v = driftRates, sd_v = SD_V, silent = TRUE)
    } else if (LBAType == 2) { #SD Uncertainty
      trialUncs[1] <- Uncs[rawData$comb[t]]
      trialUncs[2] <- Uncs[rawData$comb[t] + 4]
    
      SD_Unc <- trialUncs*GAMMA/100
      
      likelihood[t] <- n1CDF(rt = rawData$RT[t], A = A, b = B, t0 = T0, mean_v = driftRates, sd_v = SD_Unc, silent = TRUE)
    } else if (LBAType == 3) { #SP Uncertainty
      trialUncs[1] <- Uncs[rawData$comb[t]]
      trialUncs[2] <- Uncs[rawData$comb[t] + 4]
      
      UncA <- A + trialUncs * GAMMA/100
      for (i in 1:2) {
        if (UncA[i] > B[i]) {
          UncA[i] <- B[i]
        }
      }
      
      likelihood[t] <- n1CDF(rt = rawData$RT[t], A = UncA, b = B, t0 = T0, mean_v = driftRates, sd_v = SD_V, 
                             args.dist = list(posdrift = TRUE), silent = TRUE)
      
    }

    #Work out Likelihood of that choice
    if ( rawData$choice[t] == 2){
      likelihood[t] <- 1 - likelihood[t]
    }
    
    #Add uncertainty
    Uncs <- addUncLBA(uncType, Uncs, rawData, observedReward, t, valuesObserved, Qs, UNCSTART, rawData$comb[t])
    
    
  }
  
  # print(UncTable)
  
  likelihood <- array(as.numeric(unlist(likelihood)))
  
  if (any(is.nan(log(likelihood)))){
    NLL = 100000
    return(NLL)
  }
  
  if (any((log(likelihood) == -Inf))) {
    x <- tibble(likelihood) %>% 
      filter(likelihood > 0)
    
    minHolder <- min(x$likelihood)
    for (t in 1:trialNum) {
      if (log(likelihood[t]) == -Inf) {
        likelihood[t] = minHolder
      }
    }
  }
  
  NLL = -sum(log(likelihood), na.rm = TRUE)
  
  # print(params)
  # if (NLL == Inf) {
  #   print('lol')
  # }
  
  return(NLL)
  
}
